---
metatable: false
title: lvalue vs. rvalue
tags:
dateCreated: 22-го августа 2022
dateModified: 23-го августа 2022
---
# lvalue vs. rvalue

lvalue (locator value) — это выражение-объект, который занимает идентифицируемое место в памяти (имеет адрес).

rvalue — это выражение, которое не представляет объект, который занимает идентифицируемое место в памяти.

Оператор присваивания всегда ожидает lvalue с левой стороны и в данном примере эти правила везде соблюдаются:

```cpp
auto a = 12;
a = 34;
a = a + 5;
```

Инвертирование некоторых выражений приводит к ошибкам компиляции, так как и литералы `12`, `34` и выражение `a + 5` не являются lvalue. Из определения следует, что они rvalue и оператор присваивания ожидает их с правой стороны:

```cpp
34 = a;         // ERROR
(a + 5) = a;    // ERROR
```

Аналогично актуально, если мы попытаемся присвоить результату вызова функции некоторое значение. Пример:

```cpp
#include <cstdlib>

int F() {
	return 10;
}

int main() {
	F() = 20;    // ERROR
	
	return EXIT_SUCCESS;
}
```

Данное правило имеет исключение, если функция возвращает ссылку. Контрпример:

```cpp
#include <cstdlib>

auto VAR = 10;

int& F() {
	return VAR;
}

int main() {
	std::cout << "VAR = " << VAR << std::endl; // VAR = 10
	F() = 20;
	std::cout << "VAR = " << VAR << std::endl; // VAR = 20

	return EXIT_SUCCESS;
}
```

Однако это не противоречит правилу, которое гласит о том, что оператор присваивания ожидает lvalue слева, так как ссылка и является lvalue. Это может быть принципиальным, например, в перегрузках некоторых операторов таких как `[]` или `->`.

Важная ремарка: **не всем lvalue можно присвоить значение**. Пример:

```cpp
const auto a = 10;
a = 20;    // ERROR
```

Такие lvalue называют неизменяемыми.

Важным является также возможность преобразования lvalue в rvalue. Пример:

```cpp
auto a = 1;
auto b = 2;
auto c = a + b;
```

Обратите внимание, что `a` и `b` являются lvalue, но позже они подвергаются неявному преобразованию в rvalue. **Все lvalue, которые не являются массивом, функцией и не имеют неполный тип, могут быть преобразованы rvalue. Обратное неверно.**

Очевидно, что преобразование в другую сторону из rvalue в lvalue нарушило бы определение lvalue.

Подробнее о теме [тут](https://habr.com/ru/post/348198/).

Подробнее об использовании lvalue и rvalue в move-семантике БУДЕТ ТУТ.