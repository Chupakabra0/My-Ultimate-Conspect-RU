---
metatable: false
title: Виртуальные и чистые виртуальные функции в C++
tags:
dateCreated: 27-го августа 2022
dateModified: 29-го августа 2022
---
# Виртуальные и чистые виртуальные функции в C++

### Виртуальные функции

Виртуальная функция — это особый метод класса, при вызове которого выполняется "наиболее дочерний" вариант реализации. Дочерний метод вызывается тогда, когда совпадает сигнатура метода и тип возвращаемого значения с сигнатурой и типом родительского метода. Такой метод называется переопределённым.

Если функция отмечена как виртуальная, то все соответствующие переопределения тоже считаются виртуальными, даже если возле них явно не указано ключевое слова `virtual`.

Для создания виртуальной функции необходимо воспользоваться ключевым словом `virtual` перед объявлением метода:

```cpp
#include <iostream>
#include <memory>

class A {
public:
	explicit A() = default;
	
	virtual int F(int a, int b) const {
		return a + b;
	}
};

class B : public A {
public:
	explicit B() = default;

	int F(int a, int b) const override {
		return a * b;
	}
};

int main() {
	std::unique_ptr<A> a = std::make_unique<B>();
	std::cout << a->F(12, 2) << std::endl;

	return EXIT_SUCCESS;
}
```

Результат выполнения этой программы:

```
24
```

Сигнатура виртуального метода дочернего класса должна _полностью_ соответствовать сигнатуре виртуального метода родительского класса. Если у дочернего метода будет другой тип параметров, нежели у родительского, то вызываться этот метод не будет.

Необязательно, но желательно, использовать модификатор `override` после сигнатуры метода перед открывающейся фигурной скобкой дабы компилятор проверял действительно ли вы переопределяете существующий в базовом классе метод или создаёте новый. Подробнее о нём [тут](%D0%9C%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%20override.md).

Кроме того, можно запрещать переопределять тот или иной виртуальный метод. Для этого используется модификатор `final`, о котором можно почитать ТУТ.

### Чистые виртуальные функции

Чистая виртуальная функция (абстрактная функция) — это особый вид виртуальных функций, которые не имеют определения и делают класс абстрактным (то есть таким, что нельзя создать его экземпляр). Определяются эти функции в дочерних классах.

```cpp
class A {
public:
	virtual int F(int, int) const = 0;
};

class B : public A {
public:
	explicit B() = default;

	int F(int a, int b) const override {
		return a * b;
	}
};
```

При попытке создания экземпляра класса `A` мы получим ошибку компиляции, так как в классе имеется чистая виртуальная функция `F()`. Однако, если будет создан экземпляр класса `B` и сохранён в указатель на `A`, то мы сможем вызвать у него метод `F()` и благодаря механизму переопределения будет вызвана наиболее дочерняя реализация функции `F`.

Тем не менее, оказывается, что даже чисто виртуальная функция может иметь тело. Его нужно определить вне контекста класса `A`. Это может пригодиться в том случае, если нам необходима некоторая реализация чистой виртуальной функции по умолчанию, однако в то же время нам не хочется иметь дело с экземплярами базового класса. Эта реализация по умолчанию может быть вызвана в дочерних методах. Делается это так: 

```cpp
class A {
public:
	virtual int F(int a, int b) const = 0; // объявление чистой виртуальной функции
};

int A::F(int a, int b) const {
	return a + b; // реализация по умолчанию
}

class B : public A {
public:
	explicit B() = default;

	int F(int a, int b) const override {
		return a * b; // несмотря на наличие реализации по умолчанию, требуется переопредление чистой виртуальной функции
	}
};

class C : public A {
public:
	explicit C() = default;

	int F(int a, int b) const override {
		return A::F(a, b); // однако, в случае необходимости, можно явно вызвать реализацию по умолчанию
	}
};
```
