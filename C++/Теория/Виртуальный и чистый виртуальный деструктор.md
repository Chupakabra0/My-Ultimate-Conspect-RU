---
metatable: false
title: Виртуальный и чистый виртуальный деструктор
tags:
dateCreated: 7-го сентября 2022
dateModified: 7-го сентября 2022
---
# Виртуальный и чистый виртуальный деструктор

Виртуальный деструктор — это полиморфный деструктор, который вызывает после своего выполнения дочерние деструкторы.

Рассмотрим пример:

```cpp
#include <iostream>
#include <memory>

struct A {
public:
    explicit A(int a = 0) : a(new int(a)) {

    }

    A(const A&) = delete;

    A(A&&) noexcept = default;

    virtual ~A() = default;

    std::unique_ptr<int> a;
};

struct B : public A {
public:
    explicit B(double b = 0.0) : A((int)b), b(new double(b)) {

    }

    B(const B&) = delete;

    B(B&&) noexcept = default;

    ~B() override = default;

    std::unique_ptr<double> b;
};

int main() {
    std::unique_ptr<A> a = std::make_unique<B>(12.2);
    return EXIT_SUCCESS;
}
```

В данном примере деструктор у переменной `a` типа `A` будет вызван и он будет гарантировать уничтожение поля класса `a` типа `std::unique_ptr<int>`. Однако, так как в функции `main()` в переменную был сохранён указатель на объект типа `B`, то поле класса `B` `b` типа `std::unique_ptr<double>` останется неочищенным.

Чтобы указать компилятору о том, что следует вызвать дочерние переопределённые деструкторы у полиморфного класса необходимо указать ключевое слово `virtual` перед деструктором родительского класса. Пример выше будет переписан так:

```cpp
#include <iostream>
#include <memory>

struct A {
public:
    explicit A(int a = 0) : a(new int(a)) {

    }

    A(const A&) = delete;

    A(A&&) noexcept = default;

    virtual ~A() = default;

    std::unique_ptr<int> a;
};

struct B : public A {
public:
    explicit B(double b = 0.0) : A((int)b), b(new double(b)) {

    }

    B(const B&) = delete;

    B(B&&) noexcept = default;

    ~B() override = default;

    std::unique_ptr<double> b;
};

int main() {
    for (;;) {
        std::unique_ptr<A> a = std::make_unique<B>(12.2);
    }

    return EXIT_SUCCESS;
}
```

Теперь объект будет уничтожаться так: сначала будет вызван дочерний деструктор и будет уничтожена "частичка" класса `B`, после чего будет вызван родительский деструктор.

Вообще говоря, порядок вызова деструкторов будет аналогичен обратному порядку вызова конструкторов при создании этого же объекта.

Что касается чистого виртуального деструктора, то его назначение и реализация сперва кажутся неочевидными. Представьте ситуацию из примера выше, лишь с той разницей, что программисту нужно запретить создание экземпляров класса `A`.

Для этого требуется сделать его виртуальным, а для этого необходимо ввести хотя бы один чистый виртуальный метод, однако методов в классе `A` помимо конструкторов и деструкторов нет.

Решением этой проблемы может послужить чистый виртуальный деструктор. Однако, несмотря на это деструктор этого класса должен быть определён вне контекста этого самого класса. Код класса `A` будет таким:

```cpp
struct A {
public:
    explicit A(int a = 0) : a(new int(a)) {

    }

    A(const A&) = delete;

    A(A&&) noexcept = default;

    virtual ~A() = 0;

    std::unique_ptr<int> a;
};

A::~A() = default;
```

Чистая виртуальность деструктора не позволит создать экземпляр класса `A`, однако, если не определить его тело вне класса `A`, то будет получена ошибка компиляции, так как класс или должен иметь явно удалённый деструктор, или один определённый публичный деструктор.