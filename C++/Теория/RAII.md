---
metatable: false
title: RAII
tags:
dateCreated: 24-го августа 2022
dateModified: 24-го августа 2022
---
# RAII

RAII (Resource Acquisition Is Initialization) — это идиома, смысл которой заключается в том, что получение ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с его уничтожением.

В языке C++ идиома RAII реализовывается при помощи получения доступа к ресурсу внутри конструктора и его освобождении внутри деструктора. Это гарантирует безопасность при возникновении исключений.

RAII используется для любых разделяемых объектов или ресурсов, например:
- выделение памяти;
- открытие устройств, файлов, соединений;
- мьютексы, критические секции.

В языке C++ отдельного внимания заслуживают "умные указатели", которые инкапсулируют владение динамической памятью и являются важнейшим частным случаем RAII. Подробнее о низ БУДЕТ ТУТ.

Использование RAII упрощает код и помогает обеспечить корректность работы программы. Пример кода без использования RAII:

```cpp
#include <iostream>

struct A {
public:
    explicit A(int a) : a(new int(a)) {
        throw std::runtime_error("Exception in ctor");
    }

    ~A() {
        delete a;
    }

    int* a;
};

int main() {
    while (true) {
        try {
            auto *a = new A(12);
            std::cout << *a->a << std::endl;
	        delete a;
        }
        catch (const std::exception &ex) {
            std::cout << ex.what() << std::endl;
        }
    }

    return EXIT_SUCCESS;
}
```

Данная программа имеет утечки памяти, так как после возникновения исключения внутри конструктора `A` не вызывается его деструктор. Исправить положение может обработка исключения внутри самого конструктора и его передача следующему обработчику при помощи оператора `throw`:

```cpp
struct A {
public:
    explicit A(int a) : a(new int(a)) {
        try {
            throw std::runtime_error("Exception in ctor");
        }
        catch (const std::exception& ex) {
            this->Clean();
            throw ex;
        }
    }

    void Clean() {
        delete a;
    }

    ~A() {
        this->Clean();
    }

    int* a;
};
```

Однако это решение усложняет код и замедляет его. Использовании идиомы RAII через "умные указатели" элегантно решают эту проблему:

```cpp
struct A {
public:
    explicit A(int a) : a(new int(a)) {
        throw std::runtime_error("Exception in ctor");
    }

    ~A() = default;

    std::unique_ptr<int> a;
};
```

Так как `std::unique_ptr` создаётся на стеке, то при возникновении исключения в конструкторе стандарт C++ гарантирует вызов деструкторов у всех членов класса, которые были инициализированы до исключительной ситуации. В данном случае поле `a` инициализировано до выброса исключения, так как в него уже был выделен ресурс и после оператора `throw` деструктор "умного указателя" освободит в деструкторе выделенную память, ликвидировав этим самым возможность утечки.
