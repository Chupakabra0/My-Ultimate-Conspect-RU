---
metatable: false
title: ODR
tags:
dateCreated: 24-го августа 2022
dateModified: 24-го августа 2022
---
# ODR

ODR (One Definition Rule) — это правило, которое гласит о том, что любой идентификатор может иметь сколь угодно много объявлений, но лишь одно определение.

Рассмотрим пример:

`func.hpp`:
```cpp
int Sum(int a, int b) {
	return a + b;
}
```

`func.cpp`:
```cpp
#include "func.hpp"
```

`main.cpp`:
```cpp
#include <iostream>

#include "func.hpp"

int main() {
	std::cout << Sum(12, 34) << std::endl;
	return EXIT_SUCCESS;
}
```

В данном примере мы получим ошибку линковки. В заголовочном файле `func.hpp` мы **объявили и определили** функцию `Sum()`. Этот заголовочный файл был включён дважды: в файл `main.cpp` и файл `func.cpp`. Компиляция проходит успешно, препроцессор заменяет директивы `#include "func.hpp"` на содержимое этого самого файла.

Как итог, на этапе линковки мы получаем **2 объявления и 2 определения функции** и компоновщик понятия не имеет, какое определение использовать для вызова `Sum(12, 34)`, что приводит к ошибке `LNK2005`.

Также можно получить ошибку компиляции, если убрать лишний `func.cpp` и попытаться дважды включить заголовочный файл `func.hpp`. Так как в нём отсутствуют include-guard-ы, он будет включён дважды в `main.cpp` и компилятор столкнётся с ошибкой повторного определения `C2084`.

Для того, чтобы заставить наш пример компилироваться и линковаться необходимо следовать нескольким правилам:
- ВСЕГДА использовать include-guard-ы в заголовочных файлах (подробнее о них БУДЕТ ТУТ);
- писать объявления функций в заголовочных файлах, а определения — в исходных файлах (об исключениях тут чуть позже).

Перепишем пример:

`func.hpp`:
```cpp
#pragma once

int Sum(int, int);
```

`func.cpp`:
```cpp
#include "func.hpp"

int Sum(int a, int b) {
	return a + b;
}
```

`main.cpp`:
```cpp
#include <iostream>

#include "func.hpp"

int main() {
	std::cout << Sum(12, 34) << std::endl;
	return EXIT_SUCCESS;
}
```

Разберём подробнее, что тут происходит. В данном примере препроцессор подставит содержимое файла `func.hpp` в исходные файлы, как и в прошлый раз. После прогона препроцессора файлы `.cpp` будут выглядеть так:

`func.cpp`:
```cpp
int Sum(int, int);

int Sum(int a, int b) {
	return a + b;
}
```

`main.cpp`:
```cpp
#include <iostream>

int Sum(int, int);

int main() {
	std::cout << Sum(12, 34) << std::endl;
	return EXIT_SUCCESS;
}
```

Иными словами, на место `#include "func.hpp"` было вставлено объявление функции `Sum()`. В `func.cpp` помимо этого размещено объявление и определение функции `Sum()`. Итого: в файле `func.cpp` **2 объявления и одно определение**.

В `main.cpp` также размещено **одно объявление** функции `Sum()`, что является ничем иным как предварительным объявлением, что позволит компилятору дать понять, что идентификатор `Sum()` для нас означает, а компоновщик сможет найти его определение извне.

Подытожим: наш проект, который состоит из 3 файлов (одного заголовочного и двух исполняемых) содержит **3 объявления и одно определение** функции `Sum()`, что в свою очередь гарантирует нам соблюдение правила ODR.

### Исключения

Функция объявленная и определённая в заголовочном файле с ключевым словом `inline` или `static` может быть определена в разных единицах трансляции. Подробнее об этих ключевых словах БУДЕТ ТУТ и БУДЕТ ТУТ Пример:

`func.hpp`:
```cpp
#pragma once

inline int Sum(int a, int b) { // or "static int" or even "inline static int"
	return a + b;
}
```

`main.cpp`:
```cpp
#include <iostream>

#include "func.hpp"

int main() {
	std::cout << Sum(12, 34) << std::endl;
	return EXIT_SUCCESS;
}
```

Аналогичные правила действуют для объявлений-определений классов и шаблонов.
