---
metatable: false
title: SFINAE
tags:
dateCreated: 22-го августа 2022
dateModified: 22-го августа 2022
---
# SFINAE

SFINAE (Substitution Failure Is Not An Error) — это принцип работы компилятора, который говорит о том, что когда подстановка параметра шаблона заканчивается неудачей, то компилятор не будет выбрасывать ошибку, вместо этого попытается найти более удачную специализацию шаблона.

Код ниже демонстрирует принцип работы SFINAE в полной красе:

```cpp
#include <iostream>
#include <list>

template<class T>
void F(T a) {
	std::cout << "1: " << a << std::endl;
}

template<class T>
void F(typename T::value_type a) {
	std::cout << "2: " << a << std::endl;
}

int main(const int argc, char** argv) {
	std::list<int> l{ -1, 2, 0, 4 };

	F<int>(12);
	F<std::list<int>>(*l.begin());

	return EXIT_SUCCESS;
}
```

В консоль будет выведено это:

```
1: 12
2: -1
```


Вызов `F<int>(12)` предсказуемо приведёт к использованию первого шаблона с `T` в качестве аргумента. Первая же подстановка в специализацию шаблона дала положительный результата.

Вызов `F<std::list<int>>(l.front())` также попробует воспользоваться первым шаблоном, однако это приведёт к неудаче, так как тип параметра шаблона `std::list<int>` не совпадает с типом аргумента `int` .

Первая подстановка была провалена, однако компилятор продолжил поиск более подходящего варианта, в следствии этого поиска идеальным вариантом оказалась вторая специализация шаблона, так как у `std::list<int>` есть псевдоним `value_type`, как того требует эта специализация и проблем с типами нет.

Если дать возможность компилятору самостоятельно вывести параметры шаблонов, то обе функции воспользуются первой специализацией шаблона, ибо в обоих случаях будет выведен тип параметра `int`.

Тема SFINAE тесно связна с темой type_traits, о которой можно БУДЕТ ПОЧИТАТЬ ТУТ.

Детальнее о SFINAE [тут](https://shaharmike.com/cpp/sfinae).
